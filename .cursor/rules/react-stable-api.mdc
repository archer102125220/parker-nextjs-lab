---
description: React Stable API policy - prioritize stable APIs with proper hook selection
globs:
  - "components/**/*.tsx"
  - "hooks/**/*.ts"
  - "app/**/*.tsx"
---

# React Stable API Policy (‚ö†Ô∏è CRITICAL)

## Rule

This project prioritizes **React Stable APIs**, **avoids experimental syntax**, and requires **proper hook selection** based on use case.

## ‚úÖ Complete React 19 Stable Hooks List

### State Hooks
| Hook | Description |
|------|-------------|
| `useState` | Declare and update state variables |
| `useReducer` | Complex state logic (multiple sub-values or depends on previous state) |

### Context Hook
| Hook | Description |
|------|-------------|
| `useContext` | Subscribe to React Context, avoid prop drilling |

### Ref Hooks
| Hook | Description |
|------|-------------|
| `useRef` | Access DOM elements or store mutable values (no re-render) |
| `useImperativeHandle` | Customize ref value exposed to parent (with forwardRef) |

### Effect Hooks
| Hook | Description |
|------|-------------|
| `useEffect` | Side effects (after paint, asynchronous) |
| `useLayoutEffect` | Side effects (before paint, synchronous) |
| `useInsertionEffect` | CSS-in-JS libraries, fires before useLayoutEffect |
| `useEffectEvent` | Capture reactive values for effect, without triggering re-run |

### Performance Optimization Hooks
| Hook | Description |
|------|-------------|
| `useMemo` | Memoize calculated values |
| `useCallback` | Memoize function definitions |

### Scheduling Hooks
| Hook | Description |
|------|-------------|
| `useTransition` | Mark UI updates as "transitions", can be interrupted |
| `useDeferredValue` | Defer re-rendering of non-urgent UI |

### Other Hooks
| Hook | Description |
|------|-------------|
| `useId` | Generate stable unique IDs (SSR consistent) |
| `useSyncExternalStore` | Subscribe to external stores |
| `useDebugValue` | Custom label in DevTools |

### React 19 New Hooks (Stable)
| Hook | Description |
|------|-------------|
| `useActionState` | Simplify form action and submission state |
| `useFormStatus` | Access form's pending status |
| `useOptimistic` | Optimistic UI updates |
| `use` | Read Promise/Context (can be called conditionally) |

## ‚úÖ Hook Selection Guidelines (MUST FOLLOW)

### Performance Optimization (REQUIRED when applicable)
| Scenario | Hook |
|----------|------|
| Expensive calculations | `useMemo` |
| Callback passed to child components | `useCallback` |
| Prevent unnecessary re-renders | `memo` |

### State Management
| Scenario | Hook |
|----------|------|
| Simple state | `useState` |
| Complex state logic | `useReducer` |
| Share state across components | `useContext` |
| Form action state (React 19) | `useActionState` |
| Optimistic updates | `useOptimistic` |

### Side Effects
| Scenario | Hook |
|----------|------|
| Data fetching, subscriptions, timers | `useEffect` |
| Visual rendering sync (prevent flicker) | `useLayoutEffect` |
| CSS-in-JS style injection | `useInsertionEffect` |
| Reactive events inside effects | `useEffectEvent` |

### Scheduling & Performance
| Scenario | Hook |
|----------|------|
| Non-blocking UI updates | `useTransition` |
| Defer non-urgent rendering | `useDeferredValue` |

### RTK vs useContext (When using Redux Toolkit)

| Use RTK for | Use useContext for |
|-------------|-------------------|
| Global app state (user, cart, notifications) | Theme Provider (MUI ThemeContext) |
| Cross-page shared data | Locale/i18n (next-intl) |
| Persisted state | Local component tree state |
| Complex async data (RTK Query) | Third-party Provider (React Query, SWR) |
| State needing DevTools debugging | Component library internal state (FormContext) |

**Quick Decision Rule:**
```
Need global, persistent, debuggable? ‚Üí RTK
Only in local component tree / Provider-based? ‚Üí useContext
```

## ‚ùå Anti-Patterns to Avoid

```tsx
// ‚ùå BAD: Creating new function on every render when passed to child
<ChildComponent onClick={() => handleClick(id)} />

// ‚úÖ GOOD: Memoized callback
const memoizedClick = useCallback(() => handleClick(id), [id]);
<ChildComponent onClick={memoizedClick} />

// ‚ùå BAD: Recalculating on every render
const expensiveResult = items.filter(i => i.active).map(i => transform(i));

// ‚úÖ GOOD: Memoized calculation
const expensiveResult = useMemo(
  () => items.filter(i => i.active).map(i => transform(i)),
  [items]
);

// ‚ùå BAD: Using useState for values that don't need re-render
const [timerIdState, setTimerId] = useState<number>();

// ‚úÖ GOOD: Using useRef for mutable values
const timerIdRef = useRef<number>();
```

## ‚úÖ React 19 New Hooks Examples

### useActionState - Form Action State
```tsx
// ‚úÖ GOOD: Managing form submission state with useActionState
async function submitForm(prevState: FormState, formData: FormData) {
  const result = await saveData(formData);
  return { success: result.ok, message: result.message };
}

function MyForm() {
  const [state, formAction, isPending] = useActionState(submitForm, { success: false });
  
  return (
    <form action={formAction}>
      <input name="email" type="email" />
      <button disabled={isPending}>
        {isPending ? 'Submitting...' : 'Submit'}
      </button>
      {state.message && <p>{state.message}</p>}
    </form>
  );
}
```

### useOptimistic - Optimistic UI Updates
```tsx
// ‚úÖ GOOD: Optimistic update while waiting for server response
function TodoList({ todos }: { todos: Todo[] }) {
  const [optimisticTodos, addOptimisticTodo] = useOptimistic(
    todos,
    (state, newTodo: Todo) => [...state, { ...newTodo, pending: true }]
  );
  
  async function addTodo(formData: FormData) {
    const newTodo = { id: Date.now(), text: formData.get('text') as string };
    addOptimisticTodo(newTodo); // Immediately show in UI
    await saveTodoToServer(newTodo); // Then save to server
  }
  
  return (
    <form action={addTodo}>
      {optimisticTodos.map(todo => (
        <li key={todo.id} style={{ opacity: todo.pending ? 0.5 : 1 }}>
          {todo.text}
        </li>
      ))}
    </form>
  );
}
```

### useTransition - Non-blocking UI Updates
```tsx
// ‚úÖ GOOD: Keep UI responsive during expensive state updates
function SearchResults() {
  const [query, setQuery] = useState('');
  const [results, setResults] = useState<Item[]>([]);
  const [isPending, startTransition] = useTransition();

  function handleSearch(e: React.ChangeEvent<HTMLInputElement>) {
    const value = e.target.value;
    setQuery(value); // Urgent: update input immediately
    
    startTransition(() => {
      // Non-urgent: can be interrupted
      setResults(filterLargeDataset(value));
    });
  }
  
  return (
    <>
      <input value={query} onChange={handleSearch} />
      {isPending && <Spinner />}
      <ResultsList results={results} />
    </>
  );
}
```

## ‚ùå Avoid: Experimental Features

- React Compiler / React Forget (experimental)
- Any feature marked as "Canary" or "Experimental" in React docs
- Unstable APIs (prefixed with `unstable_`)

---

## üîç Deep Check Checklist

### Quick Reference for Component Review

When reviewing React components, use this checklist to ensure you perform **deep checks**, not just basic checks.

#### 1. Props ‚Üí State Synchronization
```typescript
// üîç Search Pattern
useEffect(() => {
  setState(props.xxx);
}, [props.xxx]);

// ‚úÖ Should be
const value = useMemo(() => props.xxx, [props.xxx]);
// or use props.xxx directly
```

#### 2. External State Subscription
```typescript
// üîç Search Pattern
useEffect(() => {
  window.addEventListener('event', handler);
  return () => window.removeEventListener('event', handler);
}, []);

// ‚úÖ Should be
useSyncExternalStore(subscribe, getSnapshot);
// or use existing hooks like useWindowSize
```

#### 3. Multiple Related States
```typescript
// üîç Search Pattern: 5+ useState in same component
const [state1, setState1] = useState(...);
const [state2, setState2] = useState(...);
const [state3, setState3] = useState(...);
const [state4, setState4] = useState(...);
const [state5, setState5] = useState(...);

// ‚úÖ Should be
const [state, dispatch] = useReducer(reducer, initialState);
```

#### 4. Uncached Calculations
```typescript
// üîç Search Pattern: calculations in render
const result = array.filter(...).map(...);
const isActive = pathname.startsWith('/xxx');

// ‚úÖ Should be
const result = useMemo(() => array.filter(...).map(...), [array]);
const isActive = useMemo(() => pathname.startsWith('/xxx'), [pathname]);
```

#### 5. Effect with Callback Dependencies
```typescript
// üîç Search Pattern
const callbackRef = useRef(callback);
useEffect(() => {
  callbackRef.current = callback;
}, [callback]);

// ‚úÖ Should be (React 19)
const onEvent = useEffectEvent(() => {
  callback();
});
```

#### 6. Visual Synchronization
```typescript
// üîç Search Pattern: syncing visual state
useEffect(() => {
  setInternalValue(externalValue);
}, [externalValue]);

// ‚úÖ Should be
useLayoutEffect(() => {
  setInternalValue(externalValue);
}, [externalValue]);
```

#### 7. Callback to Memoized Children
```typescript
// üîç Search Pattern: inline functions to memo components
const MemoChild = memo(Child);
<MemoChild onClick={() => doSomething()} />

// ‚úÖ Should be
const handleClick = useCallback(() => doSomething(), []);
<MemoChild onClick={handleClick} />
```

#### 8. Non-Render Values
```typescript
// üîç Search Pattern: state that doesn't trigger re-render
const [timerId, setTimerId] = useState<number | null>(null);

// ‚úÖ Should be
const timerIdRef = useRef<number | null>(null);
```

### Deep Check Workflow

1. **Read the component** - Understand overall structure
2. **Count useState calls** - 5+ ‚Üí consider useReducer
3. **Check useEffect** - Look for props ‚Üí state sync
4. **Check calculations** - Look for uncached operations
5. **Check callbacks** - Verify useCallback for memoized children
6. **Document findings** - List all optimization opportunities

### When to Skip Deep Checks

- Simple presentational components (< 50 lines)
- Components with only 1-2 useState
- Components with no useEffect
- Demo/test components

For all other components, **deep checks are mandatory**.

